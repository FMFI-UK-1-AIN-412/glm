#!/usr/local/bin/python3

import argparse

from errors import GLMException
from remote.context import Context

context = Context()


def generate(args):
    from student.utils import generate_students

    file_path = args.file_path
    students = generate_students(context, file_path)
    context.organization.create_repositories(students)


def init(args):
    print(
        "Either type in the correct value or if you want to skip or have already filled in the value press Enter"
    )
    print("Type in organization name or press Enter to skip")
    from core.config_loader import get_local_config_path

    local_config_path = get_local_config_path()
    organization_name = input("")
    if organization_name != "":
        try:
            file_path = f"{local_config_path}/organization_name"
            with open(file_path, "w") as f:
                f.write(organization_name + "\n")
            print(f"Writing to {file_path}")
        except IOError:
            print("Failed")

    print("Type in the name of template repository to use or press Enter to skip")
    template_name = input("")
    if template_name != "":
        try:
            file_path = f"{local_config_path}/template_repository_name"
            with open(file_path, "w") as f:
                f.write(template_name + "\n")
            print(f"Writing to {file_path}")
        except IOError:
            print("Failed")

    print("Type in user repository prefix or press Enter to skip")
    user_repository_prefix = input("")
    if user_repository_prefix != "":
        try:
            file_path = f"{local_config_path}/user_repository_prefix"
            with open(file_path, "w") as f:
                f.write(user_repository_prefix + "\n")
            print(f"Writing to {file_path}")
        except IOError:
            print("Failed")


def pulls(args):
    if args.local:
        from remote.pull_request.utils import get_local_pull_requests

        pull_requests = get_local_pull_requests(context)
        for pull in pull_requests:
            print(pull)
    if args.remote:
        from remote.pull_request.utils import get_remote_pull_requests

        # TODO: you need to remove all the previous ones, or at least mark them as closed
        pull_requests = get_remote_pull_requests(context)
        for pull in pull_requests:
            print(pull)

    if args.checkout:
        university_login = args.checkout[1]
        student = list(
            filter(
                lambda x: x.university_login == university_login,
                get_all_students(context),
            )
        )

        if len(student) != 1:
            print(
                f"No student with university login=({university_login}) found in active students"
            )
        else:
            student = student[0]
            student_repository = context.get_repository(student)
            try:
                pull_id = int(args.checkout[2])
            except ValueError:
                print("Pull id needs to be integer")
                return

            pulls = list(
                filter(
                    lambda x: x.id == pull_id,
                    student_repository.get_local_pull_requests(),
                )
            )

            if len(pulls) != 1:
                print(
                    f"Pull request for {student} with id = ({pull_id}) was not found fetching new pull requests"
                )
                pulls = list(
                    filter(
                        lambda x: x.id == pull_id,
                        student_repository.get_remote_pull_requests(),
                    )
                )

                if len(pulls) != 1:
                    print("Pull request does not exists")
                    return

            pull_request = pulls[0]
            pull_request.save()
            pull_request.checkout_pull_request()


def report(args):
    from remote.repository.utils import generate_report

    generate_report(context, report_command=args.report_command)


def testing(args):
    from remote.repository.utils import distribute_branch

    distribute_branch(context, "zadanie01")


parser = argparse.ArgumentParser(
    prog="glm", description="Git learning management system",
)
subparsers = parser.add_subparsers()

# generate subparser
generate_parser = subparsers.add_parser(
    "generate",
    help="""
    Command for generating students
""",
)
generate_parser.add_argument(
    "file_path", action="store", type=str, help="file for generating students"
)
generate_parser.set_defaults(func=generate)

# init subparser
init_parser = subparsers.add_parser(
    "init", help="Command used for setting up the environment"
)
init_parser.set_defaults(func=init)

# pull request
pulls_parser = subparsers.add_parser("pulls", help="Pull request manipulation")
pulls_parser.add_argument("--local", "-l", action="store_true")
pulls_parser.add_argument("--remote", "-r", action="store_true")
pulls_parser.add_argument("checkout", action="extend", nargs=3, type=str)
pulls_parser.set_defaults(func=pulls)

# report subparser
report_parser = subparsers.add_parser(
    "report",
    help="""
    Generate and push report for students
""",
)
report_parser.add_argument(
    "report_command",
    action="store",
    type=str,
    help="Executable file that generates reports for students",
)
report_parser.set_defaults(func=report)

# for testing
testing_parser = subparsers.add_parser(
    "test", help="Dirty testing, tries pushing branch testing-branch to all students"
)
testing_parser.set_defaults(func=testing)

args = parser.parse_args()

try:
    if hasattr(args, "func"):
        args.func(args)
    else:
        parser.print_help()
except GLMException as error:
    error.show()
